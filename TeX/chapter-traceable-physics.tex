\chapter{Traceable Physics Models}
\label{chap:physics}

This thesis also contributes computational implementations of several key physics models for aircraft design that are traceable within the example code transformations framework introduced in Section \ref{sec:aerosandbox}, AeroSandbox. The broad motivation for this contribution stems from the observation that ``ease-of-model-implementation'' has historically proven to be one of the most important factors for determining whether an MDO paradigm can achieve use in industry. More specifically, the goals of this contribution are to:

\begin{enumerate}
    \item Stress-test the feasibility of code transformations in practice—how much added user effort and expertise is required to bring typical engineering analyses into a code-transformations-based MDO tool? To what extent can existing code be used as-is? Finally, the thesis aims to identify any specific computational elements that cause ``pain points'' when attempting to make an analysis traceable.
    \item Jump-start future applied research by providing a set of modular, plug-and-play analyses that can be used to quickly build a variety of aircraft design optimization problems. Since the long-term goal of this research direction is to establish whether the proposed MDO paradigm improves practicality, many practical aircraft design problems must be posed. Creating a set of modular general-purpose building blocks reduces the need to write similar analysis code repeatedly, saving time for designers.
\end{enumerate}

To achieve these goals, this thesis contributes the traceable implementations of the analyses given in Table \ref{tab:models_to_contribute}. This set of analyses was deliberately chosen to be mathematically diverse, spanning a wide range of common code patterns in scientific computing. The types of attributes that each analysis is intended to stress-test are given in the right-most column of Table \ref{tab:models_to_contribute}.

\begin{table}[H]

    \centering
    \caption{A list of aircraft design analyses that the thesis implements within a code transformations framework. The middle column lists the non-traceable tools for each analysis that are commonly used in industry today. The right-most column lists the computational attributes that each analysis is intended to stress-test.}
    \label{tab:models_to_contribute}
    \setstretch{1.25}
    \begin{tblr}{
        colspec={@{} X X X @{}},
        row{1}={font=\bfseries},
        hline{3-5}
    }
        \toprule
        Analysis To Contribute                             & Non-Traceable Analogue                                                                                               & Tests tracing through\ldots                                                                                                 \\ \midrule
        Vortex-Lattice Method Aerodynamics Analysis        & AVL \cite{avl}                                                                                                       & An aerospace geometry engine and discretization; large, vectorized matrix methods, like linear solves                       \\
        Nonlinear Lifting Line Aerodynamics Analysis       & Phillips and Snyder \cite{phillips_modern_2000}, Reid \cite{reid_general_2020}, Weissinger \cite{weissinger1947lift} & Nonlinear systems of equations (i.e., implicit), which often lead to value-dependent code execution (via convergence loops) \\
        Workbook-style Aerodynamics Buildup                & USAF Digital DATCOM \cite{datcom}                                                                                    & Table lookups, large amounts of conditional logic (yielding a wide, branching graph), and scalar-heavy math                 \\
        Rigid-Body Equations of Motion                     & ASWING (dynamics) \cite{aswing}                                                                                      & Ordinary differential equations, which are often implemented in a loop-heavy way (yielding a deep graph)                    \\
%        Linearized Aircraft Stability Modal Decomposition & AVL \cite{avl}                                                                                                       & More advanced matrix methods, such as an eigenvalue decomposition                                                           \\
        \bottomrule
    \end{tblr}

\end{table}

These traceable implementations offer value within the context of the thesis itself (in stress-testing the practicality of code transformations), but they also have value as a standalone contribution to the aircraft design community—even outside of design optimization. Because of the mixed-backend numerics library described in Section \ref{sec:code_syntax}, these analyses can be used independently from the design optimization context of AeroSandbox if desired. In such cases, however, they still can retain certain runtime benefits from the code transformations framework, if desired by the user. For example, a traceable workbook-style aerodynamics buildup would seamlessly enable GPU-accelerated evaluations and automatic vectorization, offering significant speedups; an example application might be real-time performance estimation for model predictive controllers or flight simulation.


\section{Vortex-Lattice Method Aerodynamics Analysis}
\label{sec:vlm}

\subsection{Method Overview}
\label{sec:vlm_theory}

The vortex-lattice method (VLM) is a low-fidelity aerodynamics analysis used to model the inviscid 3D flow field around a system of lifting surfaces (e.g., wings). It is one of the most common conceptual-level aerodynamics analyses used in aircraft design, as it is computationally inexpensive and interpretable. Common tools that implement the VLM include AVL \cite{avl} and XFLR5 \cite{xflr5}.

A VLM analysis is based on classical potential-flow theory. Because this flow field model is a linear partial differential equation, it can be quickly solved using a boundary-element method representation by superimposing Green's-function kernels. These kernels model disturbances in the flow field that are induced by the lifting surfaces. In a VLM analysis, these kernels are modeled as a collection of \emph{horseshoe vortices} that are distributed along the wing in a regular lattice pattern (distributed in both spanwise and chordwise directions). A single horseshoe vortex is illustrated in Figure \ref{fig:horseshoe_vortex}. Each horseshoe vortex is a connected polyline of uniform-strength vortex filaments, with three segments: a bound vortex on the wing, and two trailing legs extending downstream to infinity\footnote{These trailing legs extend to the far-field Trefftz plane. In theory, these trailing legs should follow the local flow direction (and hence be ``force-free'' by the Kutta-Joukowski theorem), but often they are simply extended directly backwards which simplifies induced velocity computation and removes the need for an iterative wake relaxation.}. (In practice, a fourth leg consisting of a far-downstream ``starting vortex'' can be imagined to close the horseshoe vortex, which forms a ring vortex and thus satisfies the Helmholtz vortex theorems.) The Kutta condition is naturally satisfied, as the only place where the wing can shed vorticity is at the trailing edge (due to placement of the trailing legs).

\begin{figure}[h]
    \centering
    \includegraphics[width=5in]{../figures/horseshoe_vortex.png}
    \caption{Illustration of a horseshoe vortex (black) and the induced fluid velocity field around it, which is the fundamental building block of a VLM analysis. In reality the induced velocity field has global influence, but it is truncated here for conceptual clarity.}
    \label{fig:horseshoe_vortex}
\end{figure}


Each horseshoe vortex has an initially-unknown strength, and the vorticity associated with each vortex creates an induced velocity that affects the global flowfield. To solve for these $N$ unknown vortex strengths, $N$ constraints are needed. A convenient choice is to impose a \emph{flow-tangency} (also called \emph{no-penetration}) boundary condition associated with each horseshoe vortex, where the flow velocity normal to each horseshoe vortex is zero. It is not immediately obvious at which location this flow-tangency condition (called the \emph{collocation point}) should be imposed, relative to each horseshoe vortex. As it turns out, the best choice is to discretize the wing into quadrilateral panels, then place the bound leg at the quarter-chord point of each panel, and place the collocation point at the three-quarter-chord point. This choice results in higher-order convergence with respect to discretization resolution than any other choice, with derivation for this given by Katz and Plotkin \cite{katz_lowspeed_2004}. (One way to intuitively understand this reasoning is that the VLM is essentially a 3D analogue of 2D thin airfoil theory.)

Because of the linearity of the governing equations, the unknown horseshoe vortex strengths can be solved as a linear system of equations. Due to the global influence of each vortex on the flowfield, this linear system of equations is dense and asymmetric, so it is typically solved using LU factorization. The solution to this linear system gives the vortex strengths, which can then be used to reconstruct the flowfield around the lifting surfaces. The vortex strengths are also conveniently equal to the local difference in pressure coefficient between the top and bottom surfaces of the wing, which can be used to visually interpret the flow field. Lift force computation is usually performed using the Kutta-Joukowski theorem on each bound leg. Drag force calculation (which only includes induced drag, as a VLM is inviscid) can be accurately performed using a Trefftz plane wake integral. Further details on this analysis formulation are available in work by Katz and Plotkin \cite{katz_lowspeed_2004} and Drela \cite{drela_flight_2013}.

\subsection{Implementation}

\subsubsection{Discretization}

Based on this theory, a vortex lattice method was implemented into AeroSandbox as a traceable analysis. One of tasks when implementing this analysis is discretizing the geometry (i.e., generate a mesh) in a code-transformations compatible way. Because discretization of a high-level geometry representation is such a common task in engineering analysis, an aircraft geometry stack was built within AeroSandbox to facilitate this. This stack allows one to represent an aircraft geometry at a conceptual level (i.e., within a hierarchical data structure that is not tied to any specific analysis), and then to generate a variety of degenerate geometry representations from this conceptual geometry. These degenerate geometry representations could be a series of 1D beams (for structural analysis), a mean camber line geometry representation (for a VLM aerodynamics analysis), a 3D panel geometry representation (for visualization or for CFD analysis), or any other representation that is needed for a specific analysis. Examples of such degenerate geometry representations that are possible are illustrated in Figure \ref{fig:degen_geometry}. This capability to separate the concept of geometry from its representation makes it much easier to implement multi-physics analysis that may be required in MDO problems.

Conceptually, the ideas behind this geometry stack are inspired by the degenerate geometry representation capabilities of OpenVSP \cite{mcdonald_open_2022}, with the difference that this is built on top of a traceable numerics core. Because of this, these meshes gain all the properties enabled by code transformations, such as differentiable meshing. Furthermore, if analyses are built on top of this geometry stack, the analysis can be end-to-end differentiable throughout both discretization and solution.

This unified, vertically-integrated workflow contrasts with many current design optimization workflows, which instead usually treat meshing and solving as separate black-box tools. In cases where end-to-end gradients are required (i.e., aerodynamic shape optimization with respect to a set of design variables), the usual strategy is to compute gradients for each process and then later to stitch them together. For example, a meshing tool might use forward-mode automatic differentiation\footnote{or, if the mesh has a deterministic connectivity (i.e., hyperbolic marching from a surface), one could use a method with similar properties, like complex-step differentiation or finite-differencing}, while a solver might use a discrete adjoint of the governing PDE to obtain mesh gradients. Stitching these gradients together is a perfectly viable solution from a computational perspective, but as a practical matter it often requires a fair amount of boilerplate code from the user. In contrast, unifying the meshing and solution processes within a code transformations framework eliminates the need for the user to manually interact with component partials, lessening the expertise required to build a differentiable analysis.

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.32\textwidth}
        \includegraphics[width=\textwidth]{../figures/geometry_concept-crop.pdf}
        \caption{Concept-level geometry representation, corresponding to the raw data structures within the AeroSandbox geometry stack.}
        \label{fig:geometry_concept}
    \end{subfigure}
    \begin{subfigure}{0.32\textwidth}
        \includegraphics[width=\textwidth]{../figures/geometry_mean_camber-crop.pdf}
        \caption{Mean camber line degenerate geometry representation, which is used during VLM analysis.}
        \label{fig:geometry_mean_camber}
    \end{subfigure}
    \begin{subfigure}{0.32\textwidth}
        \includegraphics[width=\textwidth]{../figures/geometry_panel-crop.pdf}
        \caption{3D panel degenerate geometry representation, which can be used in other aerodynamic analyses.}
        \label{fig:geometry_panel}
    \end{subfigure}
    \caption{Illustration of several possible degenerate geometry representations produced by the AeroSandbox geometry stack. This removes the need for individual disciplinary analyses to re-implement their own meshing tools, creating a clearer API for new analysis tool development.}
    \label{fig:degen_geometry}
\end{figure}

\subsubsection{Solution Methodology Considerations}

With meshing complete, the governing system of equations described in Section \ref{sec:vlm_theory} can be implemented. Within the context of a code transformations framework, an interesting question is whether this system should be solved explicitly or implicitly. To clarify the difference here:

\begin{itemize}
    \item In an \textbf{explicit} formulation, the matrix and right-hand-side vector of the linear system of equations are explicitly constructed within the analysis code, and the system is solved using a direct solver. In the context of a broader optimization problem encompassing such a model, this means that a) the system of governing equations is solved exactly at each iteration, and b) no optimization variables or constraints are added to the solve.

    \item In an \textbf{implicit} formulation, the horseshoe vortex strengths are posed as optimization variables, and the governing equations are implemented in residual form and constrained (in the top-level optimization problem) to be driven to zero. This is analogous to a simultaneous-analysis-and-design MDO problem formulation (shown in Figure \ref{fig:sand}). Here, the matrix and right-hand-side vector of the linear system are never explicitly constructed within the analysis code (though of course, the optimization problem constraint Jacobian will essentially compute this same information). In the context of a broader optimization problem encompassing such a model, this means that a) the system of governing equations is solved approximately at each iteration, and b) optimization variables and constraints are added to the solve.

\end{itemize}

Both methods have advantages. The principal advantage of the explicit formulation is that incorporating this into a design optimization framework can yield more stable convergence, since ``correct'' (i.e., zero-residual) solutions are guaranteed at each iteration. This can be especially important in the context of a multidisciplinary optimization problem, where this VLM analysis might be combined with other analyses. Here, a fully coupled implicit system might become numerically unstable (e.g., numerically-stiff), leading to convergence difficulties.

On the other hand, the implicit formulation has the potential to be much faster, in the context of a broader optimization problem. This is because the optimizer is solving for primal feasibility (i.e., constraint violation) and dual feasibility (i.e., optimality conditions) simultaneously. An intuitive way to think about this is that the optimizer is not wasting CPU cycles by solving the analysis accurately during early iterations, when the solution is far from the optimum. Instead, the optimizer is solving the analysis just enough to ensure that the constraints are satisfied, and then moving on to the next iteration. This can lead to significant speedups (up to an order of magnitude, in the author's experience) in the context of a broader optimization problem, especially when the analysis is expensive to solve.

There are also some cases where this implicit solution can be favorable in augmented analyses. For example, if a panel method is coupled with an integral boundary layer model (e.g., in XFoil), solving the problem as a coupled system rather than a segregated disciplinary solve can resolve singularity issues that might otherwise appear \cite{drela_xfoil_1989, drela_viscousinviscid_1987, ranneberg_viiflow_2019, fidkowski_coupled_2022, zhang_threedimensional_2022}.

In the case of the present VLM implementation, both formulations are offered, with the explicit solution being the default. This is because the explicit solution is more stable and easier to debug, and because the VLM analysis is relatively inexpensive to solve. However, the implicit solution is also available, and can be used if the user desires faster convergence in the context of a broader optimization problem.

\subsection{Example Results}

Figure \ref{fig:vlm} shows the results of a VLM analysis performed using AeroSandbox, using a generic glider design and a prescribed aerodynamic operating point. At the moderately high paneling resolution shown here ($N=700$ panels), solution takes about 0.25 seconds on a laptop-grade CPU. The surface color shows the vortex strength (or equivalently, $\Delta C_p$ across the wing), while the streamlines show the flow field.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{../figures/vlm.png}
    \caption{AeroSandbox VLM analysis results for a simple glider geometry at a prescribed aerodynamic operating point. Surface color shows the vortex strength (or equivalently, $\Delta C_p$ across the wing). Streamlines show the flow field.}
    \label{fig:vlm}
\end{figure}

Quantitative validation results for this VLM analysis are shown later in Section \ref{sec:aero_validation}, where the VLM can be cross-compared not only against external tools but also against the other plug-and-play aerodynamic analyses developed in this chapter. Notably, while the VLM method is quite accurate for computing induced drag, it has no mechanism to compute profile drag without augmentation by another aerodynamic method, like the buildup described in Section \ref{sec:aerobuildup}; hence, the VLM method should not be used by itself for performance analysis. It is, however, more than adequate for flight dynamics analysis, as there are few other low-fidelity aerodynamics methods that handle local velocity effects (e.g., dynamic derivatives, aerodynamic damping) as accurately.

\subsection{Aerodynamic Shape Optimization}

To demonstrate how this VLM tool can be incorporated into a broader optimization problem, we can formulate a classic aerodynamic shape optimization problem and compare our result to a known solution.

Here, we aim to find the minimum-induced-drag wing planform, by optimizing a wing's chord distribution. We assume:

\begin{itemize}[noitemsep]
    \item A fixed total lift
    \item A fixed wing area
    \item A fixed span
    \item An untwisted, uncambered, unswept, thin, planar wing
    \item Potential flow (inviscid, incompressible, irrotational, and steady)
\end{itemize}

For this fixed-span, fixed-lift case, theory shows that the minimum-induced-drag wing has an elliptical lift distribution. With the additional assumptions above, the corresponding minimum-induced-drag wing will also have an elliptical \emph{chord} distribution \cite{anderson_fundamentals_2009}.

This problem can be posed in AeroSandbox syntax using the plug-and-play VLM analysis model described in the previous section. We supply an initial guess of a simple rectangular (i.e. untapered) wing, and optimize the chord distribution. We do not know the correct angle of attack $\alpha$ to achieve our specified lift coefficient \emph{a priori}, so this becomes an additional optimization variable. The VLM is implemented, here using just one spanwise panel for each unknown chord variable—typically, a higher resolution ($\sim 4$ panels per optimization variable) would be used for numerical stability, but this is used to demonstrate numerical robustness of the implementation here.

Surprisingly, the entire optimization problem can be written in less than 40 lines of code, allowing it to be shown in its entirety in Listing \ref{lst:vlm_optimization}. This serves as a good illustration of the motivation behind developing these plug-and-play models for a code transformations framework—the modularity allows complex optimization problems to be posed with minimal code.

\begin{listing}[H]
    \begin{minted}{python}
import aerosandbox as asb
import aerosandbox.numpy as np

opti = asb.Opti()  # Initialize an optimization environment.

N = 16  # Spanwise resolution
y = np.sinspace(0, 1, N, reverse_spacing=True)  # Spanwise locations along the wing.
chords = opti.variable(init_guess=1 / 8, n_vars=N, lower_bound=0)  # Chord dist.
wing = asb.Wing(  # Defines the wing geometry.
    symmetric=True,
    xsecs=[  # Cross sections ("XSecs") of the wing
        asb.WingXSec(
            xyz_le=[  # Location of each cross-section's leading edge
                -0.25 * chords[i],  # This keeps the quarter-chord-line straight.
                y[i],  # Our (known) span locations for each section.
                0
            ],
            chord=chords[i],
        )
        for i in range(N)
    ]
)

aero = asb.VortexLatticeMethod(  # Compute aerodynamics using the VLM analysis
    airplane=asb.Airplane(wings=[wing]),  # The geometry to analyze
    op_point=asb.OperatingPoint(  # Aerodynamic operating condition
        velocity=1,  # A fixed velocity; unimportant due to nondimensionalization.
        alpha=opti.variable(init_guess=5, lower_bound=0, upper_bound=30)  # Angle of attack
    ),
    spanwise_resolution=1,  # Uses one panel per wing cross-section
).run()

opti.subject_to([
    aero["CL"] == 1,  # We want a fixed lift coefficient
    wing.area() == 0.25,  # We want a fixed wing area
])

opti.minimize(aero["CD"])
sol = opti.solve()
    \end{minted}
    \caption{AeroSandbox code to optimize the chord distribution of a wing to minimize induced drag.}
    \label{lst:vlm_optimization}
\end{listing}

The optimization problem is solved to tolerance within 18 IPOPT iterations, corresponding to around 10 seconds of wall-clock time on a laptop CPU. This yields the wing geometry shown in Figure \ref{fig:vlm_opt}, which is indeed elliptical in chord distribution. To confirm, the chord distribution can be directly compared to an elliptical distribution as shown in Figure \ref{fig:vlm_opt_compare}. Very slight differences appear due to numerical discretization, but as panel resolution is increased, these results converge.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{../figures/vlm_opt.png}
    \caption{Result of the AeroSandbox VLM analysis-based aerodynamic shape optimization problem. The optimized wing has an elliptical chord distribution.}
    \label{fig:vlm_opt}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{../figures/vlm_opt_compare.pdf}
    \caption{Comparison of the optimized chord distribution to the theoretical elliptical chord distribution.}
    \label{fig:vlm_opt_compare}
\end{figure}


\section{Nonlinear Lifting Line Aerodynamics Analysis}
\label{sec:ll}

\subsection{Method Overview}

While the VLM described in Section \ref{sec:vlm} is a useful tool in conceptual analysis, its inviscid nature means that it cannot capture many important aerodynamic effects. This includes profile drag effects, but also more subtle effects like nonlinear sectional lift curve slopes and local stall. Another downside of the VLM is that capturing camber effects requires a substantial number of chordwise panels, which quickly increases the size of the linear system\footnote{The solve time of this linear system scales as $\order(N^3)$ with the number of panels, so keeping the number of panels low is quite valuable.} without meaningfully improving the induced drag prediction (as this is dominated by spanwise effects).

One way to address both of these limitations is to use a lifting-line method instead of a VLM. A modern lifting-line method is best conceptually understood as a vortex lattice method with several key similarities and differences:
\begin{enumerate}
    \item First, just as with the VLM, the lifting-line method uses a potential flow model with horseshoe vortices to model the flow changes induced by the vehicle.
    \item Another difference is that in a lifting-line method the governing equation no longer comes from a flow-tangency condition. Instead, the constraint relationship comes from equating the lift force generated by the vortex (via the Kutta-Joukowski theorem) to the lift force computed using a 2D sectional model (i.e., airfoil-level aerodynamic models) and the local angle of attack. This local angle of attack includes the effects of induced downwash from the other vortices in the system, capturing 3D effects.
    \item A notable difference is that in a lifting line method only one chordwise panel is required, because camber effects are not captured by direct flow tangency over the curved surface.
\end{enumerate}

This strategy is related to prior work to generalize the lifting-line method by Reid \cite{reid_general_2020}, Phillips and Snyder \cite{phillips_modern_2000}, and ultimately has roots in work by Weissinger \cite{weissinger1947lift}. The key insight is that the lift force generated by a vortex can be related to the lift force computed using 2D sectional data by a constraint relationship. This constraint relationship allows the lifting-line method to leverage the accuracy of 2D sectional data, which can include camber effects. In almost all existing lifting-line methods, the sectional data is approximated using an affine $C_L$-$\alpha$ relationship (possibly with a nonzero $C_L$ at $\alpha=0$ to capture camber effects), because this reduces the governing system of equations to a single linear solve (just as with the VLM). This is computationally faster to solve than the true nonlinear problem. However, this also loses substantial accuracy in lift prediction, especially in cases where nonlinearities in the lift curve are important, such as near transitional Reynolds numbers and in high-lift cases. In many cases, this may make the traditional linear lifting-line method unsuitable.

Because of this, the present work implements \emph{both} a linear and nonlinear lifting line method, with the latter retaining the full (nonlinear) lift curve slope behavior. This is done by reformulating the method to be implicit, with governing equations converted into nonlinear residual form.

In both the linear and nonlinear methods, 2D sectional data is provided using \emph{NeuralFoil}, a custom physics-informed machine learning method described in Chapter \ref{chap:physics-informed-ml}. Using NeuralFoil to obtain sectional data has negligible error compared to XFoil solutions, and it has the important property of retaining $C^1$-continuity that allows for gradient-based rootfinding methods to be used in the nonlinear case. With the linear method, the NeuralFoil evaluation is numerically differentiated about the geometric angle of attack of each wing cross section\footnote{In other words, the angle of attack with respect to the freestream velocity vector (which can be computed explicitly), not the local perturbed fluid velocity vector (which is an implicit function of the initially-unknown vortex strengths)} to construct an affine $C_L(\alpha)$ dependency. Critically, because of this local linearization step about the geometric angle of attack, even the linear lifting-line method in the implementation here can capture limited stall effects—this is a unique feature of the present work compared to other lifting-line implementations.

%The nonlinear lifting-line method has one notable drawback, which is that unlike a linear lifting-line, it is not guaranteed to produce a solution. This mostly occurs  inversion of the $C_L(\alpha)$ curve, which occur

The overall lifting line methodology presented in this section represents modern thinking about the theoretical formulation of lifting-line methods, as given by Phillips and Snyder \cite{phillips_modern_2000} and Reid \cite{reid_general_2020}; this is a generalization of the historical lifting-line formulation originally given by Prandtl in the early 20th century. The general formulation presented here has been shown to work well for non-straight lifting lines, which occurs in wings with sweep or dihedral \cite{reid_general_2020, jacobs_extension_2012, phillips_liftingline_, phillips_modern_2000}.

\subsection{Implementation}

%The lifting-line method was implemented in AeroSandbox as a traceable analysis. Both the linear and nonlinear lifting lines are

The linear version is implemented similarly to the VLM implementation, where both an explicit and an implicit solve are possible. On the other hand, the fully nonlinear lifting-line method is currently only implemented as an implicit analysis.

Numerical discretization is performed by thin-surface meshing with a chordwise paneling resolution of one. The quarter-chord lines of these panels can then be connected to obtain a lifting line for the wing.

\subsection{Example Results}

Figure \ref{fig:ll} shows analogous lifting-line analysis results for the same glider example as the VLM analysis. The reduction in discretization resolution due to the elimination of chordwise refinement is immediately apparent from the lower number of discrete panels. This leads to much shorter asymptotic runtimes, especially for vehicles with complex systems of multiple interacting lifting surfaces.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{../figures/ll.png}
    \caption{AeroSandbox lifting-line analysis results for a simple glider geometry at a prescribed aerodynamic operating point. Surface color shows the vortex strength (or equivalently, $\Delta C_p$ across the wing). Streamlines show the flow field.}
    \label{fig:ll}
\end{figure}

As with the VLM, quantitative validation results for this lifting-line analysis are shown later in Section \ref{sec:aero_validation}. In general, the lifting-line method is expected to be more accurate than the VLM for aerodynamic performance prediction purposes (i.e., lift, drag, and moment prediction), due of the incorporation of 2D sectional data. The lifting line also generally leads to more interpretable results, as the local angle of attack, lift coefficient, downwash, and other properties of interest can be directly returned by the analysis. (In a VLM, these quantities must be obtained by integration along the chord, which introduces error and creates extra postprocessing work depending on the data structure of the mesh.)

On the other hand, the VLM has advantages in low-aspect-ratio cases (as spanwise flow becomes more significant, invalidating the force-free wake assumption on the straight trailing vortices), in other highly-3D flow fields, and for angular rate stability derivatives (as the VLM can better capture chord-wise variations in local velocity).


\section{AeroBuildup: A Workbook-style Aerodynamics Buildup}
\label{sec:aerobuildup}

\begin{attrib}
    This section includes content from the author's contributions to the AeroSandbox documentation \cite{asb_github}.
\end{attrib}

\subsection{Method Overview and Implementation}

While the VLM and lifting-line methods in Sections \ref{sec:vlm} and \ref{sec:ll} provide conceptual-level aerodynamics analyses with strong first-principles grounding, they are limited in their ability to capture many important aerodynamic effects. For example, compressibility effects, fuselage aerodynamics, and high-angle-of-attack aerodynamics all go beyond the capabilities of these methods. Furthermore, these methods can have scalability challenges in combined-vehicle-and-trajectory optimization problems, depending on problem formulation. For example, the \emph{Firefly} design problem of Section \ref{sec:firefly} requires aerodynamic solutions to be computed at \emph{each} of 200 unique points along the flight trajectory, at each iteration. Computing these solutions using a VLM or lifting-line method\footnote{The astute reader will notice that, in the case of a linear method where geometry and aerodynamic operating point can be separated (like the VLM), one possible strategy to improve this scaling is by saving the LU-factorization and back-substituting unique right-hand-side vectors. However, no analogous strategy exists if either the method is fully nonlinear or if the coefficient matrix depends on the operating point, as is the case with the lifting line implementation here.} increases the total optimization runtime to the point where real-time interactive design is no longer attractive (i.e., an hour or longer), limiting the tool's utility in gathering conceptual design intuition.

To address these problems and provide a practical alternative, AeroSandbox includes a rapid, vectorized aerodynamics engine called AeroBuildup. AeroBuildup's methodology essentially uses a workbook-style buildup to compute aerodynamic forces, moments, and (optionally) stability derivatives. It attempts to model viscous and compressible effects on wings and fuselages across any orientation (360 degrees of $\alpha, \beta$) and arbitrary vehicle angular rates ($p$, $q$, $r$). Just as with the VLM and lifting-line methods, the input is both the vehicle geometry\footnote{The vehicle geometry includes a reference point, which is used for moments and stability derivatives.} and an aerodynamic operating point\footnote{An operating point consists of the local atmospheric conditions, airspeed, orientation (angle of attack $\alpha$ and sideslip angle $\beta$), and angular rates ($p$, $q$, and $r$ about the three principal aircraft body axes).}.

AeroBuildup combines a variety of both theoretical and empirical models, inspired heavily by the methodology used by USAF Digital DATCOM \cite{datcom}. (Indeed, many of the submodels are directly shared with Digital DATCOM.) Compared to DATCOM, however, AeroBuildup has several advantages that make it more favorable as an analysis to use within a larger aircraft design optimization problem:

\begin{enumerate}
    \item AeroBuildup aims to \emph{smoothly} model across a wide variety of flight regimes; the model returns $C^1$-continuous aerodynamic results that span from subsonic to supersonic speeds, from attached to separated flow, and from the lowest to highest Reynolds numbers. This contrasts with DATCOM, which requires the user to select submodels appropriate to the flight regime (e.g., small-scale transonic flight), and produces discontinuous results in some cases (e.g., as soon as Mach number crosses a threshold, DATCOM instantly switches to a different wave drag model, which causes a discontinuity in the drag prediction).

    \item AeroBuildup makes minimal assumptions about the vehicle configuration. For example, with AeroBuildup any number of wings and fuselages may be specified, and these may be placed in any location; DATCOM forbids certain configurations, such as those with multiple fuselages. As another example, all lifting surfaces in AeroBuildup are simply ``Wing'' objects--the user isn't required to provide any extra semantic meaning (i.e., whether a surface is a horizontal vs. vertical stabilizer) that would change physics modeling. This contrasts with DATCOM, which requires explicit labeling. The end result is that AeroBuildup enables optimization with respect to parameters that are simply not possible with DATCOM\footnote{For example, imagine an airplane with a V-tail, where we wish to optimize the V-tail dihedral angle. DATCOM requires this to be entered as either a horizontal or vertical stabilizer, but it is not clear at what V-tail dihedral angle that switch should be made. This distinction changes DATCOM's results, but of course in reality the actual flow physics should not depend on the semantic label that we give it.}.

    \item AeroBuildup is end-to-end vectorized, which means that multiple aerodynamic operating points can be analyzed simultaneously with hardware-level (SIMD) parallelism. This is especially advantageous in a semi-empirical model like AeroBuildup, as many of the submodels consist of scalar-heavy analytical equations where vectorization buys significant speedups. Because of this vectorization, AeroBuildup is fast enough to be used in combined-vehicle-and-trajectory optimization problems, as demonstrated in Sections \ref{sec:firefly} and \ref{sec:dawn}.

    \item AeroBuildup is implemented in an accessible high-level language, Python, which makes it easier for end-users to modify or extend the analysis with problem-specific considerations. The AeroBuildup codebase is also modular and hierarchical, with heavy code re-use. For example, the same lines of code are executed for aerodynamics analysis of all wing-like components; this contrasts with DATCOM, which uses specialized code for different surfaces (e.g., a horizontal stabilizer vs. canard). This gives AeroBuildup a concise codebase with clear, isolated scopes, minimizing the logic that a new user must understand in order to make a modification.

\end{enumerate}

The basic philosophy of AeroBuildup's approach revolves around a) hierarchical decomposition of the vehicle geometry, b) aerodynamic modeling of individual pieces, and then c) corrections for interactional effects between those pieces. For example, AeroBuildup computes aerodynamics on a per-wing and per-fuselage level, and further breaks down each of these into sectional aerodynamics.

For each wing section, the freestream velocity is computed in the local frame, with streamwise, normal, and crossflow velocities. A rotation-induced local flow velocity is also added to this, which later enables downstream computation of dynamic stability derivatives. This approximate local flow information is used to compute a set of \emph{tentative} sectional aerodynamics (including viscous and compressible effects) using NeuralFoil, a physics-informed machine learning model described in Chapter \ref{chap:physics-informed-ml}. These tentative sectional aerodynamics are then corrected for the wing's self-induced downwash, for 3D compressible effects, and for other 3D effects (e.g., the unsweeping of a lifting line near the root of a swept wing). Induced drag is computed by assuming the wake flows back to the Trefftz plane by projecting the wing's lifting line in the direction of the freestream velocity. Induced drag is computed at an overall-aircraft-level rather than a wing-level, so wakes between separate lifting surfaces are correctly merged for these purposes. After these corrections, the sectional aerodynamics are integrated along the span to obtain the total aerodynamic forces and moments.

Currently, a notable omission of the AeroBuildup model is the influence of downwash from \emph{other} wings for the purposes of lift computation. This has the benefit of improving computational speed by eliminating a lifting-line-like linear solve, but it can lead to inaccuracies in the presence of strong interactions between lifting surfaces. (For example, when analyzing a conventional-configuration airplane using AeroBuildup, the effectiveness of the horizontal stabilizer will usually be slightly overestimated due to the missing downwash influence of the main wing\footnote{One way to conceptually think about this is that the effective lift-curve-slope of the horizontal stabilizer, $C_{L\alpha, h}$, should be slightly reduced due to main-wing downwash; but this effect is not captured.}.) This modeling decision ultimately comes down to a complexity vs. accuracy tradeoff, and future versions may offer to include these interactional effects as an option.

Fuselage modeling generally follows methods described by Jorgensen \cite{jorgensen_method_1973, jorgensen_prediction_1979} and MIL-HDBK-762 \cite{_design_1990}. More precisely, inviscid results are theoretically grounded in slender body theory \cite{drela_flight_2013}, while viscous effects are modeled using an infinite-length crossflow analogy with finite-length corrections. The AeroSandbox geometry stack admits both circular and non-circular fuselages \footnote{Precisely, fuselage cross sections may be superellipse curves with any positive value of the shape parameter.}, and the dependence of crossflow separation location on local fuselage curvature (i.e., corners) is modeled. Wake separation, base drag, and any associated extra lift generation is handled using empirical methods fitted to wind tunnel results on a series of typical body shapes. Likewise, local velocity overspeed and any associated wave drag in transonic cases is computed using empirical relations. These compressible considerations depend on a variety of fuselage shape factors, but most notably on the effective fineness ratio of the pressure-drop region (i.e., roughly the forward half) of the fuselage.

AeroBuildup is a fully explicit calculation method, which means that a result is guaranteed in bounded computational time, without any non-convergence issues. However, the accuracy of this result is strongly dependent on the flight regime of the case in question. For example, AeroBuildup is expected to be most accurate for typical flight conditions where theory is sound and experimental data for validation sub-models is widely available. Generally, this well-behaved region includes flows without regions of massive separation or strong shocks. (AeroBuildup also remains relatively accurate in cases with low and transitional Reynolds numbers, due to viscous methods described in Chapter \ref{chap:physics-informed-ml}.) Quantitative validation results for AeroBuildup against other methods are shown later in Section \ref{sec:aero_validation}.

On the other hand, cases at extreme flight conditions (e.g., $\alpha=90\degree$, $\M_\infty=1.00$) will be much less accurate. However, even in these cases, effort has been taken such that the results from AeroBuildup are at least order-of-magnitude correct. This improves optimization robustness, as even very strange intermediate optimization points will allow the optimizer to gain gradient information and make progress back to the region of reasonable designs.

Beyond optimization applications, however, this property of bounded computational time gives AeroBuildup in various situations that require real-time results. For example, AeroBuildup can be used as a rapid aerodynamics model within flight simulation or real-time control.

\subsection{Example Results}

To illustrate AeroBuildup's ability to rapidly compute aerodynamic results, consider the case of the \emph{MIT Firefly} air vehicle, which is described further in Section \ref{sec:firefly}. The geometry of this air vehicle is shown in Figure \ref{fig:firefly_geometry} using the AeroSandbox geometry stack. Firefly was selected to illustrate some of AeroBuildup's capabilities because its mission CONOPS (Figure \ref{fig:firefly_conops}) subjects the vehicle to an uncommonly large range of interesting aerodynamic operating conditions. These include:

\begin{enumerate}
    \item High-angle-of-attack flight, which occurs immediately after deployment from the host vehicle. The vehicle may be tumbling at this point, and must passively stabilize to controlled flight.

    \item High-transonic flight, which occurs during the initial boost phase of the vehicle's trajectory. The initial Mach number at launch is $0.8$, and depending on the combination of trajectory constraints that the user specifies, Mach numbers slightly over Mach 1 may be encountered during flight.

    \item Low-Reynolds-number flight, which occurs at all phases but especially at high altitude. For example, at the apogee of the trajectory shown in Figure \ref{fig:firefly_trajectory}, the flow Reynolds number referenced to Firefly's mean aerodynamic chord is just $53 \times 10^3$.

\end{enumerate}

Because of these considerations, Firefly is an excellent test case to show the viability of AeroBuildup to span these various flight regimes in a single model without requiring user intervention. In these cases, the following reference quantities are used, which are derived from the projected area, mean aerodynamic chord, and span of the vehicle's main wing:

% 3 equations side by side, for reference quantities
\begin{equation}
    S_{\rm ref} = 0.02335\ \text{m}^2 \qquad c_{\rm ref} = 0.05391\ \text{m} \qquad b_{\rm ref} = 0.4800\ \text{m}
\end{equation}

\subsubsection{Traditional Aerodynamics Polars}

To begin, we can compute the traditional static aerodynamic polars, which is an ``alpha sweep'': lift, drag, and moment coefficients as a function of the angle of attack $\alpha$. In Figure \ref{fig:ab_polars}, we show the AeroBuildup-computed polars for the MIT Firefly air vehicle, at a representative flight condition of sea level flight at Mach 0.15. This is comparable to the aerodynamic conditions on the Firefly vehicle at the end of its nominal trajectory\footnote{Firefly's optimized trajectory during the glide phases predictably has a nearly-constant indicated airspeed, of around 86 KIAS (44 m/s at sea level). Slight variations occur due to Reynolds effects.}, as shown in Figure \ref{fig:firefly_trajectory}. For this analysis, control surface deflections of zero are used.

\begin{figure}[h]
    \centering
    \includegraphics[width=6in]{../figures/aerobuildup_figs/polars.pdf}
    \caption{Standard static aerodynamic polars for the MIT Firefly air vehicle, computed using AeroBuildup. Analysis is an angle of attack ($\alpha$) sweep at Mach 0.15 and sea level conditions. Control surfaces are not deflected.}
    \label{fig:ab_polars}
\end{figure}

To generate the smooth plots in Figure \ref{fig:ab_polars}, 1,000 unique aerodynamic operating points were analyzed with AeroBuildup (each at a different $\alpha$). This process is benchmarked at 3.13 seconds in total on a laptop-grade CPU, or around 3 milliseconds per operating point. This is achievable due to data-level vectorization, allowing for instruction-level parallelism (SIMD) to be automatically performed. (To illustrate this, a single non-vectorized analysis takes roughly 1 second.) In either case, however, this speed combined with the ability to model viscous and compressible effects makes AeroBuildup useful for rapid aerodynamic assessment of new concepts or for aerodynamic database generation.

Figure \ref{fig:ab_polars} demonstrates that AeroBuildup captures several nuanced aerodynamic effects. For example, the lift curve captures both positive and negative stall conditions, and a lift-curve-slope nonlinearity during the attached flow regime near $\alpha=4\degree$ occurs due to sudden early upper-surface turbulent transition along the main wing. Likewise, in the moment polar, we observe a general curving-down nonlinearity, which is ultimately a consequence of the vertical displacement between the center of gravity and the neutral point. The effect of tail stall is also visible near $\alpha=13\degree$ in the moment polar, which causes a slight destabilizing effect. We also note that the moment polar shows that the vehicle requires a modest pitch-up input in order to trim at the target lift coefficient during glide ($C_L\approx 1$), which matches flight test reports by Gaubatz \cite{gaubatz_design_2024}.

\subsubsection{Stability Derivative Calculation}

AeroBuildup also supports the ability to compute stability derivatives (both static and dynamic), due to its local flow velocity computation. By default, this is computed by evaluating finite differences of the aerodynamic operating point with respect to angle of attack, sideslip, and angular rates ($\alpha, \beta, p, q, r$). This approach is the fastest strategy, because these additional analyses can be added to the vectorized evaluation enabling negligible overhead.

As an alternative to finite-differences, an interesting capability that results from the code transformations paradigm is the ability to \emph{directly} compute stability derivatives using automatic differentiation on AeroBuildup itself. Where this gets particularly unique is if this stability derivative then gets used in an optimization problem, as higher-order automatic differentiation may be required. For example, imagine we formulate an aircraft design optimization problem where the objective function is to minimize $C_{m\alpha}$. Here, we might compute $C_{m\alpha}$ by applying automatic differentiation to AeroBuildup (1 derivative). Then, we compute an exact Hessian of $C_{m\alpha}$ with respect to the design variables (2 more derivatives), to facilitate gradient-based optimization. In total, we may be performing triple-nested automatic differentiation of the original AeroBuildup analysis.

Because the operator space of the AeroSandbox numerics stack is closed under differentiation, implementing this higher-order AD is surprisingly straightforward. This fascinating capability offers unique capabilities when optimizing with respect to the evaluated gradients of an analysis, which has applications far beyond aerodynamics. Nevertheless, because AeroBuildup's implementation grants such an unusually large advantage to vectorized evaluation, simple finite-differencing is the default strategy used for stability derivative computation.

In addition to stability derivatives, other quantities of interest, like the location of the aircraft's neutral point, are computed as well. For Firefly at the Mach 0.15, sea level flight condition, AeroBuildup computes a neutral point located at $49\%$ of the main wing's root chord, or $x_{\rm np} = 241\ \rm mm$ aft of a datum placed at the vehicle's nose. For comparison, Gaubatz \cite{gaubatz_design_2024} assessed this same geometry using a vortex-lattice code (AVL \cite{avl}), which produced an estimate for the neutral point that is slightly farther aft\footnote{Note that in Gaubatz \cite{gaubatz_design_2024}, the reference datum is placed at the vehicle's tail rather than nose, so measurements must be subtracted from the vehicle length of 460 mm to convert coordinates to aircraft geometry axes with a nose datum. Note that the vehicle length of 460 mm is shorter than the bounding box of 480 mm, due to the inclusion of an external rocket igniter (briefly shown in Figure \ref{fig:firefly_conops}).}, at $x_{\rm np} = 243\ \rm mm$. Gaubatz's subsequent wind tunnel test campaign produced results\footnote{See stability derivatives reported in Table 3.2 in Gaubatz \cite{gaubatz_design_2024}.} that would indicate a neutral point at $x_{\rm np} = 236\ \rm mm$.

In any case, this indicates that the AeroBuildup result is quite consistent with both experiment and other conceptual-level aerodynamics tools. This is a particularly useful comparison, as proper computation of this neutral point reflects the fact that AeroBuildup's potential-flow-based fuselage aerodynamic computations include the destabilizing contributions of the large fuselage, which is not captured by wing aerodynamics alone.

\subsubsection{High-Angle-of-Attack Flight}

Because AeroBuildup uses sectional data that models post-stall behavior (obtained with a tool called NeuralFoil, described in Chapter \ref{chap:physics-informed-ml}), it is capable of estimating aerodynamic coefficients at extreme angles of attack and sideslip angles. This is a particularly useful capability when designing the Firefly vehicle, which must passively stabilize from a tumbling condition after deployment from the host vehicle.

For example, Figure \ref{fig:ab_high_aoa} gives a ``3D'' version of the traditional aerodynamic polars from Figure \ref{fig:ab_polars}, where these are extended to include sideslip angle $\beta$ as well as angle of attack $\alpha$, both out to $[-90\degree, +90\degree]$. In this study, the MIT Firefly air vehicle is analyzed at sea-level Mach 0.15 conditions.

Of particular interest is the ``moment flow'' diagram in the lower left of Figure \ref{fig:ab_high_aoa}, which shows how the yawing and pitching moment coefficients ($C_n$ and $C_m$) vary throughout the $\alpha, \beta$ phase space; arrows and streamlines indicate the direction that passive aerodynamic moments will tend to point the nose, from any initial vehicle orientation. This mapping is similar to a ``phase portrait'' in dynamical systems theory, though inertial effects are neglected in this strictly-static analysis. Nevertheless, this provides an excellent initial map of the vehicle's passive stability characteristics from upset flight conditions, even those well-past stall. For example, the moment flow diagram indicates that Firefly is passively stable roughly in the regime where $\beta \in [-30\degree, +30\degree]$ and for all $\alpha$, but not outside of this. This may indicate that active control inputs are required to recover from such upset conditions.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{../figures/aerobuildup_figs/high_alpha.pdf}
    \caption{A ``3D'' version of standard aerodynamic polars, where lift, drag, moment (i.e., $C_n$ and $C_m$), and aerodynamic efficiency are given as a function of \emph{both} angle of attack $\alpha$ and sideslip angle $\beta$. Analysis is for the MIT Firefly air vehicle at sea-level Mach 0.15 conditions, with $\alpha$ and $\beta$ varied. Aerodynamics computed with the AeroBuildup physics model, and given for an extreme range of $\alpha, \beta \in [-90\degree, +90\degree]$ to demonstrate post-stall modeling capability. Control surfaces are undeflected in all cases.}
    \label{fig:ab_high_aoa}
\end{figure}

This kind of information about post-stall handling qualities of a candidate airframe would ordinarily not be available until well beyond the conceptual design phase. However, AeroBuildup's rapid aerodynamic analysis capability allows for this kind of analysis to be performed in a matter of seconds, enabling the designer to make informed decisions about the vehicle's passive stability characteristics early in the design process.

\subsubsection{Transonic and Low-Reynolds Flight}

Firefly uniquely operates at both low Reynolds numbers and transonic speeds, which are two flight regimes that are traditionally difficult to model with aerodynamics tools. Moreover, the \emph{combination} of these two regimes presents further challenges, as a) limited validation data is available for such conditions, and b) these two conditions create aerodynamic design drivers that are directly opposed to each other, such as the target pressure distribution in pressure recovery zones. Further details on this inherent conflict of transonic and low-Reynolds design drivers are given by Drela \cite{drela_transonic_1992}. In short, this conflict makes it challenging for a designer to know which high-level aerodynamic effects will dominate the vehicle's performance.

AeroBuildup is capable of capturing these effects simultaneously, as shown in Figure \ref{fig:ab_transonic}. Here, the MIT Firefly air vehicle is analyzed across a range of Mach numbers $M_\infty$ and angles of attack $\alpha$. In all cases, atmospheric conditions are taken at Firefly's launch altitude of 30,000 ft. Because of this, Reynolds number also changes as a function of Mach number. In these results, several notable aerodynamic phenomena are captured:

\begin{enumerate}[noitemsep]
    \item Near the zero-speed condition ($M_\infty \leq 0.05$), the Reynolds number also drops quite low, which precipitates a rise in the drag coefficient $C_D$ and a sudden reduction in the lift-curve slope $C_{L \alpha}$ as the suction-side boundary layer cannot transition.
    \item At low subsonic conditions, the expected Prandtl-Glauert-like compressibility effects on the overall pressure distribution are visible, which cause the lift curve slope $C_{L \alpha}$ to rise with increasing Mach.
    \item At transonic speeds ($M_\infty \approx 0.8$), the onset of transonic effects is clearly visible. The Mach number at which these effects begin, $\Mcr$, is a strong function of local pressure drop, and hence, angle of attack. This cross-dependency is successfully captured by AeroBuildup. After such speeds, lift drops markedly due to a buffet model, and drag rises due to the onset of wave drag. This shock effect occurs both at positive and negative angles of attack, but the wing's ability to sustain a larger pressure drop on the suction-side surface causes these transonic effects to be more pronounced at positive angles of attack.
\end{enumerate}

\noindent This provides a unique view into this combination of nuanced aerodynamic effects that is rare to obtain at the conceptual phase. Because the impact of both transonic and low-Reynolds effects can be considered together, the designer can make a meaningful prediction about which set of competing aerodynamic design drivers is likely to dominate the vehicle's performance.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{../figures/aerobuildup_figs/transonic.pdf}
    \caption{Transonic and low-Reynolds-number aerodynamic effects can be simultaneously captured by AeroBuildup. Here, the MIT Firefly air vehicle is analyzed across a range of Mach numbers $M_\infty$ and angles of attack $\alpha$. In all cases, atmospheric conditions are taken at Firefly's launch altitude of 30,000 ft. Because of this, Reynolds number also indirectly changes as a function of Mach number.}
    \label{fig:ab_transonic}
\end{figure}


% TODO use case: aerodynamic database generation to support flight simulation or time-domain testing of control laws


\section{Cross-Validation of AeroSandbox Aerodynamics Analyses}
\label{sec:aero_validation}

To assess the accuracy of the three AeroSandbox aerodynamics analyses presented in Sections \ref{sec:vlm}, \ref{sec:ll}, and \ref{sec:aerobuildup}, a series of cross-validation studies were performed.

\subsection{Flying Wing Validation Study}

The first such validation study is based on a flying wing geometry described in NACA Report RM-A50K27 \cite{tinling_effects_1951}, which provides wind tunnel data as a point of comparison. This validation case study was originally organized by John Yost \cite{yost2022}, and was subsequently refined in collaboration with the author.

The geometry used in this study is described fully by Tinling and Kolk \cite{tinling_effects_1951}, and is also visualized in Figure \ref{fig:fw_geometry}. The wing has a $35\degree$ quarter-chord sweep, a span of $b=3.098\ \rm m$, an aspect ratio of $\AR = 10$, and a taper ratio of $\lambda=0.5$. A constant NACA $\mathrm{64_{1}A012}$ airfoil is used along the entire span, with no twist. The wing is analyzed at a Reynolds number of $\text{Re}_c=2 \times 10^6$ to match the wind tunnel conditions, corresponding to $91.3\ \rm m/s$ ($M_\infty=0.26$) at sea level.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=5in]{../figures/aero_validation/flying_wing_geometry.png}
    \caption{Three-view of the flying wing aircraft geometry used in the AeroSandbox aerodynamics validation study. Based on geometry used in wind tunnel experiements in NACA Report RM-A50K27 \cite{tinling_effects_1951}.}
    \label{fig:fw_geometry}
\end{figure}

Using this geometry and freestream conditions, we perform an angle of attack sweep using the three AeroSandbox aerodynamics analyses, to compare to wind tunnel experiment. In addition, several external conceptual-level aerodynamics tools are used for comparison, including:
\begin{itemize}[noitemsep]
    \item AVL \cite{avl} (using XFoil \cite{drela_xfoil_1989} for 2D sectional data), a vortex lattice method that is widely used in conceptual aircraft design.
    \item OpenVSP's VSPAero solver \cite{mcdonald_open_2022}, which is a 3D panel method combined with form-factor-based empirical profile drag buildups.
    \item LORAAX \cite{loraax}, a fully-coupled 3D panel and 2D (strip-wise) integral boundary layer method. An iterative solution is used to obtain a force-free wake.
\end{itemize}

AVL \cite{avl} (using XFoil \cite{drela_xfoil_1989} for 2D sectional data), OpenVSP's VSPAero conceptual aerodynamics tool \cite{mcdonald_open_2022}, and Loraax, a 3D panel and integral boundary layer code. The results of this comparison are shown in Figure \ref{fig:fw_results}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{../figures/aero_validation/flying_wing_polars-crop.pdf}
    \caption{Comparison of aerodynamic polars for the flying wing geometry at $\text{Re}_c=2 \times 10^6$. The AeroSandbox VLM, lifting-line, and AeroBuildup analyses are compared to wind tunnel data and other conceptual-level aerodynamics tools. The wind tunnel data is reproduced from NACA Report RM-A50K27 \cite{tinling_effects_1951}.}
    \label{fig:fw_results}
\end{figure}

In the lift polar of Figure \ref{fig:fw_results}, we observe that the AeroSandbox lifting line models (both quasi-linear and fully nonlinear) capture the nonlinear $C_L(\alpha)$ dependency of the wind tunnel data quite well. Likewise, the AeroBuildup method captures the shape of the lift curve reasonably well. Interestingly, the computational lifting-line methods tend to err low on this highly-swept-wing case while the AeroBuildup method tends to err high, and for exactly opposite reasons. In reality, the lifting line of a highly-swept wing will tend to follow the geometric sweep of the wing, but it will tend to unsweep near the centerline due to the influence of the other wing half. A computational lifting-line method places the aerodynamic lifting line exactly at the locus of geometric quarter-chord-points, which then underestimates the lift at the centerline. (While there \emph{should} be a dip in the lift distribution at the centerline, a computational lifting-line method will predict a more-extreme dip than reality.) On the other hand, AeroBuildup assumes a uniform downwash\footnote{This is usually a reasonable rough assumption for low-induced-drag wings with near-elliptical lift distributions, but in a highly-swept wing case this is violated.}, which results in no dip in the lift distribution near the centerline. Of course, reality is somewhere in between these two limit cases. The ASB vortex lattice method estimates the lift quite well when flow is fully attached, but as is the case with any (linear) vortex lattice method, it struggles to capture the nonlinearities in the lift curve slope near stall.

In the drag polar of Figure \ref{fig:fw_results}, the AeroSandbox lifting line models and AeroBuildup both achieve excellent agreement with the wind tunnel data. This is notable, because this polar is chiefly responsible for overall performance prediction of the aircraft. The AeroSandbox vortex lattice method does not include any profile drag handling, and is thus not expected to match other results -- as discussed in Section \ref{sec:vlm}, the primary intended use of the VLM is for flight dynamics analysis rather than performance prediction.

In the moment polar of Figure \ref{fig:fw_results}, we see that the AeroSandbox vortex lattice method achieves very close agreement with wind tunnel data until separation occurs. This is expected, as vortex lattice methods have a long and successful history of use for conceptual stability and control analysis. The AeroSandbox lifting line methods achieve good agreement on the static stability derivative $C_{m \alpha}$, but a small constant error in the $C_m$ value itself remains. This is also likely due to underestimation of the lift at the centerline, as discussed in the lift polar. The AeroBuildup method achieves closer agreement to wind tunnel data, but it predicts a more gradual onset of stall than the sudden separation seen in experiment.

One of the notable findings of this validation study is that the quasi-linear lifting line and the fully-nonlinear lifting line yield very similar results across lift, drag, and moment polars. Because of this, the quasi-linear lifting line is recommended for use in conceptual design, as it is much faster to compute. The fully-nonlinear lifting line may be useful in specific cases with extensive and important near-stall behavior.

Nevertheless, in all cases here, the discrepancies discussed are well below the threshold of accuracy needed for conceptual aircraft design purposes. (Mostly, the deviations discussed in detail here are presented for theoretical interest.) In particular, the accurate results for the $C_D$-$C_L$ polar highlight the utility of these methods for initial aircraft performance prediction.

\subsection{Sailplane Cross-Validation Study}

The second validation study aims to demonstrate the relative strengths and weaknesses of the AeroSandbox aerodynamics analyses on a more complex geometry that includes multiple wings (including a non-planar wing) and a fuselage. This study analyzes aerodynamic performance of a small remote-control-scale sailplane, which is drawn in Figure \ref{fig:glider_geometry}. The main wing has a span $b = 2\ \rm m$, a projected area of $S=0.292\ \rm m^2$, and polyhedral with outer sections angled up $11.3\degree$. The horizontal stabilizer is mounted with a geometric decalage of $5\degree$ with respect to the main wing, which keeps the vehicle in trim at zero control surface deflections. The fuselage geometry is a canted body of revolution, and is somewhat thicker than a typical sailplane to test whether fuselage $C_{m\alpha}$ and $C_{n\beta}$ effects are well-captured.

Performance is assessed at sea-level conditions with a freestream velocity of $15\ \rm m/s$, which corresponds to a relatively low Reynolds number of $\text{Re}_c = 155 \times 10^3$ referenced to the mean aerodynamic chord of the main wing.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=5in]{../figures/aero_validation/glider_geometry.png}
    \caption{Three-view of the glider aircraft geometry used in the AeroSandbox aerodynamics validation study.}
    \label{fig:glider_geometry}
\end{figure}

Figure \ref{fig:glider_results} shows the aerodynamic polars for the glider geometry, computed using the AeroSandbox VLM, lifting-line, and AeroBuildup analyses. In general, trends are relatively similar to the flying wing case. On, lift, Ggod agreement is achieved between all three models. As before, the lifting line and AeroBuildup models able to capture nonlinear lift curve effects that the VLM misses.

On the drag polar, the VLM model once again only reports induced drag (as no profile drag model is included), and thus is not expected to match the other models. The lifting line and AeroBuildup models both agree quite closely on their drag predictions across a range of lift coefficients.

On moment prediction, the lifting line and vortex lattice methods agree reasonably well within the range of angles of attacks that have mostly attached flow ($\alpha \in [-5\degree, +12\degree]$). The AeroBuildup method generally predicts a more-negative $C_{m\alpha}$ derivative; this is likely erroneous, and occurs due to the method's inability to capture the downwash effects of the main wing on the horizontal stabilizer. This is a known limitation of the AeroBuildup method, and is a tradeoff of speed vs. accuracy that could be made in future iterations of the method.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{../figures/aero_validation/glider_polars-crop.pdf}
    \caption{Comparison of aerodynamic polars for the glider geometry of Figure \ref{fig:glider_geometry}. Geometries are assessed at flight conditions corresponding to $\text{Re}_c = 155 \times 10^3$. The AeroSandbox VLM, lifting-line, and AeroBuildup analyses are cross-compared to assess agreement.}
    \label{fig:glider_results}
\end{figure}

In general, the validation studies in this section demonstrate that the AeroSandbox aerodynamics analyses generally agree with wind tunnel data, external analysis tools, and each other. These studies also indicate that different methods have different strengths and weaknesses: the vortex lattice method is useful for moment and stability derivative estimation, but AeroBuildup and lifting line methods have an advantage in force prediction and performance analysis.

\subsection{Computational Reproducibility}

All code and aircraft geometries used in these aerodynamic validation studies are publicly available within the tutorials section of the broader AeroSandbox repository, available at \url{https://github.com/peterdsharpe/AeroSandbox/tree/master/tutorial}.


\section{Rigid-Body Equations of Motion}
\label{sec:dynamics}

Code-transformations-based MDO framework are particularly well-suited for solving combined vehicle-and-trajectory optimization problems, as demonstrated with several of the aircraft design case studies of Chapter \ref{chap:design-studies}. Fundamentally, this is because the trajectory side of the problem (assuming transcription using direct collocation) forms a large-and-sparse constraint Jacobian, while the vehicle design part of the problem generally forms a small-and-dense constraint Jacobian. A framework that facilitates automatic sparsity detection can naturally deal with this varying sparsity structure without user intervention, which saves significant engineering time.

Implementation fundamentally involves three steps: a) parameterizing the system into a state vector, b) defining the equations of motion, and b) transcribing the problem into an optimization framework (i.e., discretization). All three steps can be quite tedious, and are often error-prone (and difficult to debug) due to their complexity. For example, consider the example equations of motion in Equations \ref{eq:rigid-body-eom-1}-\ref{eq:rigid-body-eom-4}; a single sign error will result in silently-incorrect results. Implementing this trajectory optimization problem manually may be necessary or desirable on problems with unique dynamics (e.g., contact dynamics during landing gear touchdown), but for many aerospace problems, much of the code is boilerplate.

Because of this, this thesis implements a general-purpose flight dynamics stack that gives the user the option to bypass this manual process. One challenge of such a general-purpose effort is that different aircraft design problems will require different levels of fidelity in the equations of motion. To handle this, the AeroSandbox dynamics stack uses a series of classes with nested inheritance, starting from the highest-allowed fidelity model, which are the 3D rigid-body equations of motion given in Equations \ref{eq:rigid-body-eom-1} to \ref{eq:rigid-body-eom-4}. This approach allows the user to select the level of fidelity that is appropriate for their problem, while minimizing the size and maintenance cost of this codebase through code reuse. Another benefit is that all classes share the same API, which enables the user to easily swap between different levels of fidelity.

\begin{example}
    \setstretch{1.25}
    \textbf{Example: General Newtonian Rigid-Body Equations of Motion}

    \noindent For a rigid 3D object with:
    \begin{itemize}[noitemsep]
        \item Mass $m$ and body-axis inertia tensor $\mat{I}$, in a gravity field with acceleration $g$ in the $+\hat{z}_e$ (Earth-frame) direction
        \item Position $[x_e, y_e, z_e]$ in the Earth frame
        \item Velocity $[u, v, w]$ in the body frame
        \item Orientation given by roll-pitch-yaw Euler angles $[\phi, \theta, \psi]$
        \item Angular velocity $[p, q, r]$ in the body frame
        \item Forces $[X, Y, Z]$ and moments $[L, M, N]$ in the body frame
    \end{itemize}

    \noindent Motion is governed by the following 12 coupled first-order differential equations, adapted from Drela \cite{drela_flight_2013}:

    \begin{equation}
        \begin{aligned}
            \dot{x}_e &= (\cos \theta \cos \psi) u + (\sin \phi \sin \theta \cos \psi - \cos \phi \sin \psi) v + (\cos \phi \sin \theta \cos \psi + \sin \phi \sin \psi) w \\
            \dot{y}_e &= (\cos \theta \sin \psi) u + (\sin \phi \sin \theta \sin \psi + \cos \phi \cos \psi) v + (\cos \phi \sin \theta \sin \psi - \sin \phi \cos \psi) w \\
            \dot{z}_e &= (- \sin \theta) u + (\sin \phi \cos \theta) v + (\cos \phi \cos \theta) w \\
        \end{aligned}
        \label{eq:rigid-body-eom-1}
    \end{equation}
    \begin{equation}
        \begin{aligned}
            \dot{\phi} &= p + q \sin \phi \tan \theta + r \cos \phi \tan \theta \\
            \dot{\theta} &= q \cos \phi - r \sin \phi \\
            \dot{\psi} &= \frac{q \sin \phi}{\cos \theta} + \frac{r \cos \phi}{\cos \theta} \\
        \end{aligned}
        \label{eq:rigid-body-eom-2}
    \end{equation}
    \begin{equation}
        \begin{aligned}
            X &= m (\dot{u} + qw - rv + g \sin \theta) \\
            Y &= m (\dot{v} + ru - pw - g \sin \phi \cos \theta) \\
            Z &= m (\dot{w} + pv - qu - g \cos \phi \cos \theta) \\
        \end{aligned}
        \label{eq:rigid-body-eom-3}
    \end{equation}
    \begin{equation}
        \begin{aligned}
            L &= I_{xx} \dot{p} + I_{xy} \dot{q} + I_{xz} \dot{r} + (I_{zz}-I_{yy}) qr + I_{yz} (q^2-r^2) + I_{xz} pq - I_{xy} pr \\
            M &= I_{xy} \dot{p} + I_{yy} \dot{q} + I_{yz} \dot{r} + (I_{xx}-I_{zz}) rp + I_{xz} (r^2-p^2) + I_{xy} qr - I_{yz} qp \\
            N &= I_{xz} \dot{p} + I_{yz} \dot{q} + I_{zz} \dot{r} + (I_{zz}-I_{xx}) pq + I_{xy} (p^2-q^2) + I_{yz} rp - I_{xz} rq \\
        \end{aligned}
        \label{eq:rigid-body-eom-4}
    \end{equation}
\end{example}

From the starting point of Equations \ref{eq:rigid-body-eom-1}-\ref{eq:rigid-body-eom-4}, the AeroSandbox dynamics stack offers users a series of simplifying assumptions that can be applied to reduce the complexity of the equations of motion. A wide variety of possible assumptions are offered, which can generally be grouped as follows:
\begin{itemize}
    \item \textbf{Dimensionality and symmetry}: Starting from the full 3D equations of motion, users can reduce to 2D or 1D equations of motion. Even a reduction to two dimensions (e.g., a range-altitude position parameterization, and assuming left-right vehicle symmetry) offers an enormous reduction in complexity, since this eliminates almost all of the gyroscopic, centrifugal, and Coriolis terms.
    \item \textbf{State parameterization}:
    \begin{itemize}
        \item With no simplifications beyond equations \ref{eq:rigid-body-eom-1}-\ref{eq:rigid-body-eom-4}, the vehicle's state vector has 12 elements (position and velocity, each in both a translational and rotational sense; each with 3 components). Here, the instantaneous control inputs to the system are forces and moments. This is referred to as an \emph{inertial} parameterization, where full motion (e.g., tumbling) can be captured.
        \item The first possible simplification is to make a \emph{point-mass} assumption, where the rotational dynamics (Equations \ref{eq:rigid-body-eom-2} and \ref{eq:rigid-body-eom-4}) are neglected. Instead, now the instantaneous control inputs are orientation: possibly the Euler angles $[\phi, \theta, \psi]$, but in a fixed-wing aircraft context this would more likely be parameterized using the aerodynamic orientation angles $[\alpha, \beta]$. This essentially assumes that vehicle can be ``pointed'' in any desired direction nearly-instantaneously, since this effect (analogous to a short-period mode in aircraft flight dynamics) is much faster than the dynamics of optimization interest\footnote{This is essentially a spectral separation assumption.}. For example, this is the parameterization used in the Firefly rocket-UAV study of Section \ref{sec:firefly}, where the performance dynamics of interest (e.g., the boost-glide trajectory of Figure \ref{fig:firefly_trajectory}) are much slower than the vehicle's orientation dynamics (e.g., the vehicle's short-period and Dutch roll modes).
        \item A second further simplification is to also eliminate the translational velocity dynamics (Equation \ref{eq:rigid-body-eom-3}). Now, the instantaneous control inputs include not only orientation, but also the velocity itself. This essentially assumes that the vehicle can be flown at any desired velocity, and that the dynamics of this velocity change are much faster than the dynamics of optimization interest. Stated another way, this assumes that transient changes in kinetic energy are so small that they can be neglected. For example, this is the parameterization used in the Dawn solar aircraft study of Section \ref{sec:dawn}, where the major dynamics of interest (e.g., solar flux) are much slower than the transient dynamics of the vehicle's velocity (e.g., phugoid mode).
    \end{itemize}
    \item \textbf{Velocity parameterization}: In all 2D and 3D cases, the velocity vector can be parameterized in either Cartesian coordinates or spherical coordinates\footnote{In 2D cases, this corresponds to polar coordinates.}. (In spherical coordinates, velocity is parameterized by a magnitude $V$; a flight path angle $\gamma$; and a bearing angle, sometimes called \emph{track}.) The underlying physics are of course identical, but both parameterizations have unique advantages in a discretized setting:
    \begin{itemize}
        \item Cartesian velocity parameterization yields simpler equations of motion, and it eliminates a singularity at $V=0$; this makes it useful for optimizing aerobatic maneuvers.
        \item Spherical velocity parameterization, on the other hand, offers greatly reduced discretization error due to the ability to use symplectic (energy-preserving) integrators. Here, the velocity magnitude maps directly on to the kinetic energy, so exact energy conservation can be enforced at the parameterization level. This is particularly important for problems involving high-$L/D$ airplanes, as the even a miniscule error in the direction of the lift force while flying a curved trajectory will cause it to perform nonzero work, leading to noticeable energy conservation error. The inherent energy conservation of spherical velocity parameterization makes it superior for performance optimization problems, since the (adversarial) optimizer is less able to exploit discretization error to find a solution that is not physically realizable. For this reason, both the Firefly and Dawn studies use spherical velocity parameterization.
    \end{itemize}
\end{itemize}

Choosing an appropriate parameterization can easily change the wall-clock solve time of a trajectory optimization problem by an order of magnitude. For example, if the Dawn solar aircraft design optimization problem were to be parameterized using the full 12-element state vector, the dynamics would span many orders of magnitude in time scale -- with a short-period mode on the order of 1 Hz, and solar dynamics on the order of 24 hours. This situation corresponds mathematically to a stiff ODE system, requiring extremely fine time resolution to remain numerically stable. By choosing a parameterization that eliminates the fast dynamics (and offering a shared API that makes such simplification straightforward), the optimization problem becomes much faster to solve and has better convergence properties. In total, the AeroSandbox dynamics stack offers 8 different ``off-the-shelf'' classes for the user to parameterized vehicle dynamics, each with different combinations of choices from the list of possible assumptions above; this allows the user to identify the appropriate level of fidelity for this problem.

In addition to parameterization, transcription of the dynamics into an optimization formulation is another common user pain point that the AeroSandbox dynamics stack aims to address. Both direct collocation\footnote{Described in more detail by Kelly \cite{kelly_introduction_2017}} and single-shooting transcription methods are supported. Empirically, direct collocation methods tend to result in optimization problems that not only solve faster but also have more stable convergence, so in general these are preferred. However, single-shooting methods enable the use of adaptive-step integrators, which can be useful in problems where stiff dynamics cannot be avoided (e.g., chemical species kinetics in a rocket engine plume, as demonstrated by Mathesius \cite{mathesius_integrated_2023}).

Under either a direct collocation or single-shooting approach, a variety of integrators are available to the user. These include Runge-Kutta methods, forward- and backward-Euler methods, a trapezoidal method, methods based on Simpson's rule, and a cubic reconstruction method. This wide gamut of integrators lets the user select an appropriate integrator, based on speed vs. accuracy and smoothness vs. discontinuity tradeoffs.

\subsection{Trajectory Optimization Case Study: Low-Altitude Air Racing Optimization}

While the \emph{Firefly} and \emph{Dawn} case studies of Chapter \ref{chap:design-studies} demonstrate the usage of the AeroSandbox dynamics stack more broadly for combined vehicle-and-trajectory optimization, this section gives a more focused case study that demonstrates the deep capabilities of the dynamics stack developed in Section \ref{sec:dynamics}.

This aircraft trajectory optimization case study focuses on fast, low-altitude flight through mountainous terrain. Ultimately, this nap-of-the-earth flight is often used for evading radar detection while reaching an objective. This task, recently popularized in prior art starring Cruise et al. \cite{topgunmaverick2022}, is a common and challenging scenario in military aviation.

The task in this case study is to fly a fighter jet between two points 75 km (40 nmi) apart, located near Riffe Lake, Washington, USA. The aircraft's aerodynamics and propulsion physics are loosely modeled after an F/A-18 in full afterburner, ultimately yielding in an average Mach number of 0.95 in the resulting trajectory. This scenario replicates on of the challenges in Microsoft's recent Flight Simulator 2020, which allows results to be compared\footnote{Flight physics will vary slightly between this case study and the Flight Simulator 2020 model, but broader strategic decisions like whether to fly over or around a mountain make for a meaningful comparison.} against known fastest times.

\begin{figure}[h]
    \centering
    \includesvg[width=\textwidth]{../figures/air-racing/trajectory.svg}
    \caption{Top-down visualization of the optimized trajectory for the air racing optimization case study, which uses the AeroSandbox dynamics stack. Trajectory follows riverbeds and valleys closely to maintain low-altitude flight.}
    \label{fig:air-racing-trajectory}
\end{figure}

The objective function of this optimization problem is a combination of flying as low as possible and as fast as possible. A (slight) regularization penalty is also added for aggressive control inputs, which encourages more human-like piloting. Quantitatively, the objective function is given by:

\begin{equation}
    \text{minimize }
    \left(
    \frac
    {\text{Total flight duration}}
    {({240\ \rm seconds})}
    \right)^2 +
    \left(
    \frac
    {\text{Average altitude}}
    {({30\ \rm feet})}
    \right) +
    10^{-3} \cdot w
\end{equation}

\noindent where the wiggliness $w$ is obtained by integrating the squared second-time-derivative of each control input\footnote{Control inputs include the angle of attack $\alpha$, the bank angle $\phi$, and the throttle setting. Inputs are nondimensionalized by reference values before integration into the $w$ measure.}, and summing them.

The vehicle dynamics are parameterized using the AeroSandbox dynamics stack; the selected parameterization is 3D, uses point-mass equations of motion, and uses a spherical velocity representation. The optimization problem is transcribed using direct collocation, and cubic reconstruction is used for integration. This cubic reconstruction is discrete, creating a cubic local function representation of each integrand over each interval based on a 4-point stencil\footnote{This stencil uses the two endpoints of each interval, and one point beyond either side of the interval.}; this reconstruction is then exactly integrated over each interval.

In addition to the constraints obtained via direct collocation of the vehicle dynamics, the following additional constraints are added to the optimization problem:
\begin{itemize}
    \item Initial and final state constraints.
    \item A path constraint that the altitude must be at least 15 meters (49 feet) above the terrain elevation. This elevation is obtained via a digital elevation model (DEM) of the terrain produced by the U.S. Geological Survey at 1 arc-second (approx. 30 m) resolution \cite{usgs_2022_dem}. To implement this in a way that is $C^1$-continuous with respect to collocation node location, the elevation model is represented as an interpolated 2D hermite spline using the AeroSandbox numerics stack \cite{sharpe_core_2022}.
    \item The track angle may not deviate from the overall goal direction (i.e., start-to-finish) by more than $75\degree$. This prevents the optimizer from flying in circles, which can cause spurious local minima.
    \item The vehicle's G-loading must remain in the range $[{-0.5\ \rm G}, {+9.0\ \rm G}]$ at all times, due to both structural and human factors limitations\footnote{One motivation for this rather-modest negative G limit is to test whether the optimizer can discover ridge-crossing maneuvers, as demonstrated in Figure \ref{fig:air-racing-3}.}.
\end{itemize}

This optimization problem is nonlinear and also highly nonconvex -- a simple example of this nonconvexity is the multiple local minima that can occur if the optimizer flies to the left or right of a mountain. To mitigate this, the optimization problem is warm-started using an initial guess from a simple 2D-grid relaxation using an $\mathrm{A}^*$ search algorithm\footnote{Another good simple choice here would be to initialize using a 3D Dubins path, as demonstrated by Vana et al. \cite{vana20minimal}.}.

The resulting trajectory is shown in a top view in Figure \ref{fig:air-racing-trajectory}, and in 3D views in Figures \ref{fig:air-racing-2} and \ref{fig:air-racing-3}. The trajectory is highly dynamic, with the vehicle navigating a series of quick sequential max-G turns in opposite directions to follow the terrain. The trajectory tends to follow low-altitude areas, like river beds and valleys, which shows the influence of the objective function. The mean altitude above ground level (AGL) throughout the optimized flight trajectory is just 18 meters (59 feet), which is remarkably close to the 15 meter minimum altitude constraint.

To achieve this low-altitude flight, the trajectory optimization algorithm naturally ``discovers'' a low-altitude ridge-crossing maneuver, which involves an inverted high-G turn. This is shown in Figure \ref{fig:air-racing-3}. This maneuver, which is also used in real-world military nap-of-the-earth flight, allows lower altitudes to be maintained by exploiting the much-higher positive G limit of the vehicle compared to its negative G limit. This is a good example of how the trajectory optimization algorithm can discover novel and unexpected solutions to complex problems, even without any explicit user guidance.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{../figures/air-racing/2.png}
    \caption{3D visualization of the optimized trajectory for the air racing optimization case study, which uses the AeroSandbox dynamics stack for both numerical formulation and visualization. Vehicle and wingtip ribbon drawn at 70x scale for visibility. Here, the vehicle navigates a series of quick sequential max-G turns in opposite directions to follow the terrain.}
    \label{fig:air-racing-2}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{../figures/air-racing/3.png}
    \caption{3D visualization of the optimized trajectory for the air racing optimization case study, which uses the AeroSandbox dynamics stack for both numerical formulation and visualization. Vehicle and wingtip ribbon drawn at 70x scale for visibility. Here, we show that the trajectory optimization algorithm naturally ``discovers'' a low-altitude ridge-crossing maneuver, which involves an inverted high-G turn. This is a common maneuver practiced in military nap-of-the-earth flight.}
    \label{fig:air-racing-3}
\end{figure}

In short, this case study demonstrates the deep capabilities of the AeroSandbox dynamics stack to model complex vehicle dynamics with challenging constraints. When combined with the more performance-oriented case studies in Chapter \ref{chap:design-studies}, these examples show how a code-transformations-based MDO framework facilitates flexible modeling up and down the fidelity ladder.

The code (including data, optimization problem formulation, and visualizations) needed to reproduce this case study is publicly available at \url{https://github.com/peterdsharpe/air-racing-optimization}. This source also includes links to video demonstrations of the optimized trajectory for further inspection.

%\subsection{}

